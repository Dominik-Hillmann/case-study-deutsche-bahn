package com.bahn.casestudy.download;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gargoylesoftware.htmlunit.WebClient;
import com.gargoylesoftware.htmlunit.html.HtmlElement;
import com.gargoylesoftware.htmlunit.html.HtmlPage;

/**
 * A client to download the most recent accessable CSV for the Betriebsstellen.
 * @implNote The URLs do not get sorted after they got sorted by year.
 * This needs change but works as long as there are no two CSVs per year.
 */
public class CsvDownloader extends WebClient {
	/** Generated by Eclipse. */
	private static final long serialVersionUID = 7764457643038693219L;
	
	/** The URL on which to find the Betriebsstellen CSVs. */
	private final String DOWNLOAD_URL = "https://data.deutschebahn.com/dataset/data-betriebsstellen.html";
	/** The path to which the new CSV gets saved. */
	private final String SAVE_PATH = "./src/main/resources/static/operation-sites-data.csv";
	
	/** Exctract the year from a CSV name. */
	private final Pattern YEAR_PATTERN = Pattern.compile("Stand(\\d{4})-");
	/** Extract the month from a CSV name. */
	// private final Pattern MONTH_PATTERN = Pattern.compile("-(\\d{2}).csv");
	
	/** The most recent year found in CSV names. */
	private int youngestYear = 0;
	/** The most recent month found in CSV names. */
	private int youngestMonth = 0;
	
	
	/**
	 * Constructor setting the additional download of JS and CSS to false.
	 */
	public CsvDownloader() {
		getOptions().setCssEnabled(false);
		getOptions().setJavaScriptEnabled(false);
	}
	
	
	/**
	 * Get the URL of the newest CSV.
	 * @param urls All CSV URLs.
	 * @return The URL of the newest CSV.
	 */
	private String determineNewestCsv(List<String> urls) {
		Map<String, Integer> years = getYearsMap(urls);		

		years.values().forEach(year -> {
			if (year > youngestYear) {
				youngestYear = year;
			}
		});
		
		Map<String, Integer> filteredByYear = where(years, youngestYear);
		
		filteredByYear.values().forEach(month -> {
			if (month > youngestMonth) {
				youngestMonth = month;
			}
		});
		
		Map<String, Integer> filteredByMonth = where(filteredByYear, youngestMonth);
		
		String youngestUrl = (String) filteredByMonth.keySet().toArray()[0];		
		return youngestUrl;
	}
	
	
	/**
	 * Creates a map that maps an URL onto its years.
	 * @param urls The URLs which to map.
	 * @return The map.
	 */
	Map<String, Integer> getYearsMap(List<String> urls) {
		Map<String, Integer> years = new HashMap<String, Integer>();
		Matcher matcher;
		
		for (String url : urls) {
			matcher = YEAR_PATTERN.matcher(url);
			if (matcher.find()) {
				int year = Integer.parseInt(matcher.group(1));
				years.put(url, year);
			}		
		}
		
		return years;		
	}
	
	
	/**
	 * Filters a URL-year map by where the date is the same.
	 * @param map The map which gets filtered.
	 * @param dateNum The value for which to search.
	 * @return The filtered map.
	 */
	private Map<String, Integer> where(Map<String, Integer> map, int dateNum) {
		Map<String, Integer> filtered = new HashMap<String, Integer>();
		map.forEach((url, num) -> {
			if (num == dateNum)
				filtered.put(url, num);
		});
		
		return filtered;
	}
	
	
	/**
	 * Downloads and saves the newest Betriebsstellen CSV to its standard path.
	 * @throws IOException If the connection fails or the CSV cannot be saved.
	 */
	public void saveNewestCsv() throws IOException {
		HtmlPage page = getPage(DOWNLOAD_URL);
		@SuppressWarnings("unchecked")
		List<HtmlElement> csvItems = (List<HtmlElement>) page.getByXPath("//ul[@class='dropdown-menu']");
		List<String> csvUrls = new ArrayList<String>();
		csvItems.forEach(item -> {
			csvUrls.add(item
				.getElementsByTagName("a")
				.get(1)
				.getAttribute("href"));
		});
		
		String newestUrl = determineNewestCsv(csvUrls);
		downloadCsv(newestUrl);
	}
	
	
	/**
	 * Download a CSV from the {@code url}.
	 * @param url The URL from which to download.
	 * @throws MalformedURLException The URL does not lead to a website.
	 * @throws IOException If the connection or the saving fails.
	 */
	private void downloadCsv(String url) throws MalformedURLException, IOException {
		Files.copy(
			new URL(url).openStream(),
			Paths.get(SAVE_PATH),
			StandardCopyOption.REPLACE_EXISTING
		);
	}
} 
